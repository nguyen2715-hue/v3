# -*- coding: utf-8 -*-
"""
API Key Rotation Manager with Intelligent Rate Limiting

Features:
- Per-key usage tracking and cooldowns
- Exponential backoff (2s, 4s, 8s) on rate limits
- 60s cooldown after exhausting retries on a key
- Minimum 2s interval between calls on same key
- Smart rotation that skips rate-limited keys
"""
import time
from typing import Callable, Optional, Any, List
from dataclasses import dataclass, field
from datetime import datetime, timedelta


@dataclass
class KeyState:
    """Track state for a single API key"""
    key: str
    last_used: float = 0.0
    retry_count: int = 0
    cooldown_until: float = 0.0
    total_calls: int = 0
    
    def is_available(self) -> bool:
        """Check if key is available (not in cooldown)"""
        return time.time() >= self.cooldown_until
    
    def time_until_available(self) -> float:
        """Get seconds until key becomes available"""
        return max(0.0, self.cooldown_until - time.time())


class APIKeyRotationManager:
    """
    Manages API key rotation with intelligent rate limiting
    
    Usage:
        manager = APIKeyRotationManager(['key1', 'key2', 'key3'])
        
        def api_call(key: str) -> Any:
            # Make your API call with the key
            response = requests.post(url, headers={'Authorization': f'Bearer {key}'})
            return response.json()
        
        result = manager.call_with_rotation(api_call)
    """
    
    # Configuration
    MIN_INTERVAL_BETWEEN_CALLS = 5.0  # Minimum seconds between calls on same key
    BACKOFF_DELAYS = [3.0, 6.0, 12.0]  # Exponential backoff delays
    EXHAUSTED_COOLDOWN = 90.0  # Cooldown after exhausting all retries
    MAX_RETRIES_PER_KEY = 3  # Maximum retries before cooldown
    
    def __init__(self, api_keys: List[str], log_callback: Callable = None):
        """
        Initialize rotation manager
        
        Args:
            api_keys: List of API keys to rotate through
            log_callback: Optional callback for logging messages
        """
        if not api_keys:
            raise ValueError("At least one API key is required")
        
        self.key_states = [KeyState(key=key) for key in api_keys]
        self.current_index = 0
        self.log_callback = log_callback
    
    def log(self, message: str):
        """Log message if callback is provided"""
        if self.log_callback:
            self.log_callback(message)
    
    def get_next_available_key(self) -> Optional[KeyState]:
        """
        Get next available key that's not in cooldown
        
        Returns:
            KeyState if available, None if all keys are in cooldown
        """
        start_index = self.current_index
        attempts = 0
        
        while attempts < len(self.key_states):
            key_state = self.key_states[self.current_index]
            
            if key_state.is_available():
                # Check minimum interval since last use
                time_since_last = time.time() - key_state.last_used
                if time_since_last >= self.MIN_INTERVAL_BETWEEN_CALLS:
                    return key_state
                else:
                    # Need to wait a bit
                    wait_time = self.MIN_INTERVAL_BETWEEN_CALLS - time_since_last
                    self.log(f"[RATE LIMIT] Key needs {wait_time:.1f}s cooldown")
                    time.sleep(wait_time)
                    return key_state
            
            # Try next key
            self.current_index = (self.current_index + 1) % len(self.key_states)
            attempts += 1
        
        # All keys are in cooldown
        return None
    
    def mark_key_used(self, key_state: KeyState):
        """Mark key as used and update last_used timestamp"""
        key_state.last_used = time.time()
        key_state.total_calls += 1
    
    def handle_rate_limit(self, key_state: KeyState):
        """
        Handle rate limit error for a key
        
        Applies exponential backoff:
        - 1st retry: wait 2s
        - 2nd retry: wait 4s
        - 3rd retry: wait 8s
        - After 3 retries: 60s cooldown
        """
        key_state.retry_count += 1
        
        if key_state.retry_count <= len(self.BACKOFF_DELAYS):
            # Exponential backoff
            delay = self.BACKOFF_DELAYS[key_state.retry_count - 1]
            self.log(f"[BACKOFF] Retry {key_state.retry_count}/{self.MAX_RETRIES_PER_KEY}, waiting {delay}s")
            time.sleep(delay)
        else:
            # Exhausted retries, long cooldown
            key_state.cooldown_until = time.time() + self.EXHAUSTED_COOLDOWN
            self.log(f"[COOLDOWN] Key exhausted, cooling down for {self.EXHAUSTED_COOLDOWN}s")
            key_state.retry_count = 0  # Reset for next time
    
    def handle_success(self, key_state: KeyState):
        """Handle successful API call - reset retry count"""
        key_state.retry_count = 0
    
    def call_with_rotation(
        self, 
        api_call: Callable[[str], Any],
        max_total_attempts: int = None
    ) -> Optional[Any]:
        """
        Call API with automatic key rotation and rate limiting
        
        Args:
            api_call: Function that takes an API key and makes the call
            max_total_attempts: Maximum total attempts across all keys (default: len(keys) * 3)
            
        Returns:
            Result from api_call if successful, None if all attempts failed
        """
        if max_total_attempts is None:
            max_total_attempts = len(self.key_states) * self.MAX_RETRIES_PER_KEY
        
        total_attempts = 0
        
        while total_attempts < max_total_attempts:
            # Get next available key
            key_state = self.get_next_available_key()
            
            if key_state is None:
                # All keys in cooldown, wait for shortest cooldown
                min_wait = min(k.time_until_available() for k in self.key_states)
                if min_wait > 0:
                    self.log(f"[WAIT] All keys cooling down, waiting {min_wait:.1f}s")
                    time.sleep(min_wait)
                    continue
            
            # Try API call
            total_attempts += 1
            self.mark_key_used(key_state)
            
            try:
                self.log(f"[CALL] Attempt {total_attempts}/{max_total_attempts} (Key #{self.current_index + 1})")
                result = api_call(key_state.key)
                
                # Success!
                self.handle_success(key_state)
                self.current_index = (self.current_index + 1) % len(self.key_states)  # Rotate for next call
                return result
                
            except Exception as e:
                error_msg = str(e).lower()
                
                # Check if it's a rate limit error
                if '429' in error_msg or 'rate limit' in error_msg or 'quota' in error_msg:
                    self.log(f"[RATE LIMIT] Key #{self.current_index + 1} rate limited")
                    self.handle_rate_limit(key_state)
                    self.current_index = (self.current_index + 1) % len(self.key_states)  # Try next key
                else:
                    # Other error, log and try next key
                    self.log(f"[ERROR] API call failed: {e}")
                    self.current_index = (self.current_index + 1) % len(self.key_states)
        
        # All attempts exhausted
        self.log(f"[FAILED] All {max_total_attempts} attempts exhausted")
        return None
    
    def get_stats(self) -> dict:
        """Get statistics about key usage"""
        return {
            'total_keys': len(self.key_states),
            'keys': [
                {
                    'index': i + 1,
                    'total_calls': state.total_calls,
                    'retry_count': state.retry_count,
                    'available': state.is_available(),
                    'cooldown_remaining': state.time_until_available()
                }
                for i, state in enumerate(self.key_states)
            ]
        }