# -*- coding: utf-8 -*-
"""
Image Generation Service with API Key Rotation and Rate Limiting
Supports: Gemini, Imagen 4, DALL-E 3
"""
import base64
import json
import mimetypes
import os
import time
from typing import Optional

import requests

from services.core.key_rotation_manager import APIKeyRotationManager


class ImageGenError(Exception):
    """Custom exception for image generation errors"""
    pass


def gemini_image_endpoint(api_key: str) -> str:
    """Get Gemini 2.0 Flash Experimental image generation endpoint"""
    return f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key={api_key}"


def _encode_image_to_base64(image_path: str) -> dict:
    """
    Encode image file to base64 for Gemini API multimodal input
    
    Args:
        image_path: Path to image file
        
    Returns:
        Dict with inline_data format for Gemini API
        
    Raises:
        ImageGenError: If image encoding fails
    """
    try:
        with open(image_path, 'rb') as f:
            img_bytes = f.read()
        
        img_b64 = base64.b64encode(img_bytes).decode('utf-8')
        mime_type = mimetypes.guess_type(image_path)[0] or 'image/jpeg'
        
        return {
            "inline_data": {
                "mime_type": mime_type,
                "data": img_b64
            }
        }
    except Exception as e:
        raise ImageGenError(f"Failed to encode image {image_path}: {e}")


def _extract_image_from_response(data: dict) -> bytes:
    """
    Extract image bytes from Gemini API response with detailed error handling
    
    Args:
        data: API response dictionary
        
    Returns:
        Image bytes
        
    Raises:
        ImageGenError: If image extraction fails
    """
    try:
        # Debug: Print response structure
        import json as json_module
        response_preview = json_module.dumps(data, indent=2, ensure_ascii=False)[:800]
        print(f"[DEBUG] API Response preview:\n{response_preview}\n")
        
        candidates = data.get("candidates", [])
        if not candidates:
            # Check for errors
            if "error" in data:
                error_msg = data.get("error", {}).get("message", "Unknown error")
                raise ImageGenError(f"API Error: {error_msg}")
            
            # Check for content filtering
            prompt_feedback = data.get("promptFeedback", {})
            if prompt_feedback:
                block_reason = prompt_feedback.get("blockReason", "UNKNOWN")
                safety_ratings = prompt_feedback.get("safetyRatings", [])
                raise ImageGenError(f"Content blocked: {block_reason}, Safety: {safety_ratings}")
            
            raise ImageGenError(f"No candidates. Response keys: {list(data.keys())}")
        
        parts = candidates[0].get("content", {}).get("parts", [])
        if not parts:
            raise ImageGenError("No parts in response")
        
        inline_data = parts[0].get("inlineData", {})
        img_b64 = inline_data.get("data")
        
        if not img_b64:
            raise ImageGenError("No image data in response")
        
        return base64.b64decode(img_b64)
        
    except ImageGenError:
        raise
    except Exception as e:
        raise ImageGenError(f"Failed to extract image: {e}")


def generate_image_gemini(prompt: str, timeout: int = None, retry_delay: float = 2.0, api_key: str = None) -> bytes:
    """
    Generate image using Gemini 2.0 Flash Experimental (legacy single-key function)
    
    Args:
        prompt: Image generation prompt
        timeout: Request timeout in seconds
        retry_delay: Delay between retries
        api_key: Google API key
        
    Returns:
        Generated image bytes
        
    Raises:
        ImageGenError: If generation fails
    """
    if not api_key:
        raise ImageGenError("API key is required")
    
    url = gemini_image_endpoint(api_key)
    
    payload = {
        "contents": [{
            "parts": [{"text": prompt}]
        }],
        "generationConfig": {
            "temperature": 0.9,
            "topK": 40,
            "topP": 0.95,
        }
    }
    
    headers = {"Content-Type": "application/json"}
    
    try:
        response = requests.post(url, json=payload, headers=headers, timeout=timeout or 120)
        response.raise_for_status()
        
        data = response.json()
        return _extract_image_from_response(data)
        
    except requests.exceptions.RequestException as e:
        raise ImageGenError(f"Request failed: {e}")


def generate_image_with_rate_limit(
    prompt: str,
    api_keys: list = None,
    model: str = "gemini",
    aspect_ratio: str = "1:1",
    reference_images: list = None,
    logger=None,
    log_callback=None
) -> Optional[bytes]:
    """
    Generate image with intelligent API key rotation and rate limiting
    
    This function uses the new APIKeyRotationManager to handle:
    - Per-key usage tracking and cooldowns
    - Exponential backoff (2s, 4s, 8s) on rate limits
    - 60s cooldown after exhausting retries on a key
    - Minimum 2s interval between calls on same key
    - Smart rotation that skips rate-limited keys
    
    Args:
        prompt: Image generation prompt (REQUIRED)
        api_keys: List of API keys to rotate through (optional, uses config if not provided)
        model: Model to use (gemini, dalle, imagen_4, etc.)
        aspect_ratio: Image aspect ratio (e.g., "9:16", "16:9", "1:1", "4:5")
        reference_images: List of image paths to use as references (model/product images)
        logger: Optional callback function for logging (alias for log_callback)
        log_callback: Optional callback function for logging
    
    Returns:
        Generated image bytes or None if generation fails
        
    Note:
        - For Imagen 4: Automatically normalizes 4:5 to 3:4 (closest supported ratio)
        - For Gemini: Accepts any aspect ratio from UI
    """
    # Support both logger and log_callback parameter names
    log_fn = logger or log_callback
    
    def log(msg):
        if log_fn:
            log_fn(msg)
    
    # Load API keys if not provided
    if not api_keys:
        from services.core.key_manager import get_all_keys, refresh
        refresh()
        api_keys = get_all_keys('google')
    
    if not api_keys:
        log("[ERROR] No Google API keys available")
        return None
    
    log(f"[IMAGE GEN] Using {len(api_keys)} API keys with intelligent rotation")
    
    # Normalize aspect ratio for Imagen 4
    normalized_ratio = aspect_ratio
    if model.lower() == 'imagen_4':
        # Imagen 4 doesn't support 4:5, normalize to 3:4
        if aspect_ratio == "4:5":
            normalized_ratio = "3:4"
            log(f"[ASPECT RATIO] Normalized {aspect_ratio} to {normalized_ratio} for Imagen 4")
    
    # Call appropriate generation function with key rotation
    try:
        if model.lower() in ("gemini", "imagen_4"):
            log(f"[IMAGE GEN] Tạo ảnh với {model}...")
            
            # Build generation config with aspect ratio hint if provided
            generation_config = {
                "temperature": 0.9,
                "topK": 40,
                "topP": 0.95,
            }
            
            # Add aspect ratio to prompt for better results
            aspect_hint = ""
            if normalized_ratio:
                aspect_hint = f" [Aspect ratio: {normalized_ratio}]"
            
            enhanced_prompt = prompt + aspect_hint if aspect_hint else prompt
            log(f"[DEBUG] Enhanced prompt: {enhanced_prompt[:200]}...")
            
            # Use APIKeyRotator for key rotation with shared API call logic
            def api_call_with_key(api_key: str) -> bytes:
                """Make API call with given key"""
                url = gemini_image_endpoint(api_key)
                
                # Build parts list starting with text prompt
                parts = [{"text": enhanced_prompt}]
                
                # Add reference images if provided (max 4 images: 2 model + 2 product)
                if reference_images:
                    log(f"[REFERENCE] Adding {len(reference_images[:4])} reference images to payload")
                    for idx, img_path in enumerate(reference_images[:4]):
                        try:
                            img_part = _encode_image_to_base64(img_path)
                            parts.append(img_part)
                            log(f"[REFERENCE] Image {idx+1} encoded: {os.path.basename(img_path)}")
                        except Exception as e:
                            log(f"[WARNING] Failed to encode reference image {idx+1}: {e}")
                
                # Add safety settings to allow more content
                safety_settings = [
                    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
                ]
                
                payload = {
                    "contents": [{
                        "parts": parts
                    }],
                    "generationConfig": generation_config,
                    "safetySettings": safety_settings
                }
                
                headers = {"Content-Type": "application/json"}
                
                response = requests.post(url, json=payload, headers=headers, timeout=120)
                response.raise_for_status()
                
                data = response.json()
                return _extract_image_from_response(data)
            
            # Initialize rotation manager
            rotation_manager = APIKeyRotationManager(api_keys, log_callback=log)
            
            # Call with rotation (handles all retries, backoff, cooldowns internally)
            result = rotation_manager.call_with_rotation(api_call_with_key)
            
            if result:
                log("[IMAGE GEN] ✓ Generated successfully")
                return result
            else:
                log("[IMAGE GEN] ✗ All API keys exhausted or rate limited")
                return None
                
        elif model.lower() == "dalle":
            log("[IMAGE GEN] DALL-E 3 not yet implemented")
            return None
        else:
            log(f"[ERROR] Unknown model: {model}")
            return None
            
    except Exception as e:
        log(f"[ERROR] Image generation failed: {e}")
        return None