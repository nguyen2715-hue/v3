
import json
import os

from PyQt5.Qt import QDesktopServices
from PyQt5.QtCore import QLocale, QSize, Qt, QThread, QUrl
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import (
    QCheckBox,
    QComboBox,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QTableWidget,
    QTableWidgetItem,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from utils import config as cfg

from .text2video_panel_impl import _ASPECT_MAP, _LANGS, _VIDEO_MODELS, _Worker, build_prompt_json
from config.system_prompts import get_expert_system_prompt, EXPERT_TOPICS










class Text2VideoPane(QWidget):
    def __init__(self, parent=None):
        self._cards_state = {}  # scene->data
        super().__init__(parent)
        self._ctx = {}
        self._title = "Project"
        self._character_bible = None  # Part D: Store character bible
        self._script_data = None  # Store script data for bible generation
        self._build_ui()
        self._apply_styles()
        # Initialize folder label
        

    def _build_ui(self):
        root = QHBoxLayout(self); root.setSpacing(12); root.setContentsMargins(8,8,8,8)

        # LEFT (1/3) - 9-row redesigned layout
        colL = QVBoxLayout(); colL.setSpacing(8)

        # Row 1: Project name
        rowp = QHBoxLayout(); rowp.addWidget(QLabel("<b>T√™n d·ª± √°n:</b>"))
        self.ed_project = QLineEdit(); self.ed_project.setPlaceholderText("Nh·∫≠p t√™n d·ª± √°n (ƒë·ªÉ tr·ªëng s·∫Ω t·ª± t·∫°o)")
        rowp.addWidget(self.ed_project,1); colL.addLayout(rowp)

        # Row 2: Idea text area (INCREASED HEIGHT: 160px from 100px)
        colL.addWidget(QLabel("<b>√ù t∆∞·ªüng (ƒëo·∫°n vƒÉn):</b>"))
        self.ed_idea = QTextEdit(); self.ed_idea.setAcceptRichText(False)
        self.ed_idea.setLocale(QLocale(QLocale.Vietnamese, QLocale.Vietnam))
        self.ed_idea.setPlaceholderText("Nh·∫≠p √Ω t∆∞·ªüng th√¥ (<10 t·ª´)‚Ä¶")
        self.ed_idea.setMaximumHeight(160)  # ‚Üê CHANGED from 100 to 160
        colL.addWidget(self.ed_idea)

        # Row 3: Expert Topic (RENAMED: "B·∫°n l√† chuy√™n gia")
        row3 = QHBoxLayout()
        row3.addWidget(QLabel("<b>B·∫°n l√† chuy√™n gia:</b>"))  # ‚Üê RENAMED
        self.cb_expert_topic = QComboBox()
        try:
            from config.system_prompts import EXPERT_TOPICS
            self.cb_expert_topic.addItems(EXPERT_TOPICS)
        except:
            self.cb_expert_topic.addItems(["Kh√¥ng chuy√™n bi·ªát (General)"])
        self.cb_expert_topic.setToolTip("AI s·∫Ω vi·∫øt theo g√≥c nh√¨n chuy√™n gia")
        row3.addWidget(self.cb_expert_topic,1)
        colL.addLayout(row3)

        # Row 4: Script Style + Video Style (SIDE BY SIDE)
        row4 = QHBoxLayout()
        row4.addWidget(QLabel("<b>Phong c√°ch k·ªãch b·∫£n:</b>"))
        self.cb_script_style = QComboBox()
        self.cb_script_style.addItems([
            "Chu·∫©n (Standard)","H√†i h∆∞·ªõc (Comedy)","H√†nh ƒë·ªông (Action)",
            "C·∫£m ƒë·ªông (Emotional)","B√≠ ·∫©n (Mystery)","T√†i li·ªáu (Documentary)",
            "Vlog c√° nh√¢n","Luxury/Premium","Minimalist"
        ])
        row4.addWidget(self.cb_script_style,1)
        
        row4.addWidget(QLabel("<b>Phong c√°ch video:</b>"))
        self.cb_style = QComboBox()
        self.cb_style.addItems([
            "ƒêi·ªán ·∫£nh (Cinematic)","Ho·∫°t h√¨nh Nh·∫≠t (Anime)","T√†i li·ªáu","Quay th·ª±c",
            "3D/CGI","Stop‚Äëmotion","M√†u n∆∞·ªõc","Cyberpunk","Noir","Fantasy","Sci‚ÄëFi",
            "T·ªëi gi·∫£n","Vlog","Doanh nghi·ªáp","Tr∆∞ng b√†y s·∫£n ph·∫©m","Lifestyle","Th·ªÉ thao","Du l·ªãch"
        ])
        row4.addWidget(self.cb_style,1)
        colL.addLayout(row4)

        # Row 5: Duration + Videos per scene (SIDE BY SIDE)
        row5 = QHBoxLayout()
        row5.addWidget(QLabel("<b>Th·ªùi l∆∞·ª£ng (s):</b>"))
        self.sp_duration = QSpinBox(); self.sp_duration.setRange(3, 3600); self.sp_duration.setValue(20)
        row5.addWidget(self.sp_duration,1)
        
        row5.addWidget(QLabel("<b>S·ªë video/c·∫£nh:</b>"))
        self.sp_copies = QSpinBox(); self.sp_copies.setRange(1, 5); self.sp_copies.setValue(1)
        row5.addWidget(self.sp_copies,1)
        colL.addLayout(row5)

        # Row 6: Aspect ratio + Language (SIDE BY SIDE)
        row6 = QHBoxLayout()
        row6.addWidget(QLabel("<b>T·ªâ l·ªá khung h√¨nh:</b>"))
        self.cb_ratio = QComboBox(); self.cb_ratio.addItems(["16:9","9:16","1:1","4:5","21:9"])
        row6.addWidget(self.cb_ratio,1)
        
        row6.addWidget(QLabel("<b>Ng√¥n ng·ªØ:</b>"))
        self.cb_out_lang = QComboBox()
        for name, code in _LANGS: self.cb_out_lang.addItem(name, code)
        self.cb_out_lang.currentIndexChanged.connect(self._on_language_changed)
        row6.addWidget(self.cb_out_lang,1)
        colL.addLayout(row6)

        # Row 7: Voice selector (NEW!)
        row7 = QHBoxLayout()
        row7.addWidget(QLabel("<b>Gi·ªçng n√≥i trong video:</b>"))
        self.cb_voice = QComboBox()
        self.cb_voice.setToolTip("Gi·ªçng ƒë·ªçc voiceover (ƒë·ªìng nh·∫•t gi·ªØa c√°c video)")
        row7.addWidget(self.cb_voice,1)
        colL.addLayout(row7)
        # Populate voices for default language
        self._populate_voices()

        # Row 8: Video model
        row8 = QHBoxLayout()
        row8.addWidget(QLabel("<b>Model t·∫°o video:</b>"))
        self.cb_model = QComboBox(); self.cb_model.addItems(_VIDEO_MODELS)
        row8.addWidget(self.cb_model,1)
        colL.addLayout(row8)

        # Row 9: Up Scale 4K + Auto-download (SIMPLIFIED, NO FOLDER SELECTOR)
        row9 = QHBoxLayout()
        self.cb_upscale = QCheckBox("Up Scale 4K")
        self.cb_upscale.setStyleSheet("font-size: 14px; font-weight: 700;")
        row9.addWidget(self.cb_upscale)
        
        self.cb_auto_download = QCheckBox("T·ª± ƒë·ªông t·∫£i video")
        self.cb_auto_download.setChecked(True)
        self.cb_auto_download.setStyleSheet("font-size: 14px; font-weight: 700;")
        row9.addWidget(self.cb_auto_download)
        row9.addStretch()
        colL.addLayout(row9)

        # Buttons: Auto + Stop
        hb = QHBoxLayout()
        self.btn_auto = QPushButton("‚ö° T·∫°o video t·ª± ƒë·ªông (3 b∆∞·ªõc)")
        self.btn_auto.setObjectName("btn_warning")
        self.btn_auto.setMinimumHeight(44)
        self.btn_stop = QPushButton("‚èπ D·ª´ng")
        self.btn_stop.setObjectName("btn_gray")
        self.btn_stop.setMaximumWidth(80)
        self.btn_stop.setEnabled(False)
        hb.addWidget(self.btn_auto)
        hb.addWidget(self.btn_stop)
        colL.addLayout(hb)

        self.btn_open_folder = QPushButton("üìÅ M·ªü th∆∞ m·ª•c d·ª± √°n")
        self.btn_open_folder.setObjectName("btn_primary_open")
        colL.addWidget(self.btn_open_folder)

        colL.addWidget(QLabel("<b>Console:</b>"))
        self.console = QTextEdit(); self.console.setReadOnly(True); self.console.setMinimumHeight(120)
        colL.addWidget(self.console, 0)

        # RIGHT (2/3) - Result tabs
        colR = QVBoxLayout(); colR.setSpacing(8)

        # Hidden table (legacy)
        self.table = QTableWidget(0, 6)
        self.table.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.table.setHorizontalHeaderLabels(["C·∫£nh","Prompt (VI)","Prompt (ƒê√≠ch)","T·ªâ l·ªá","Th·ªùi l∆∞·ª£ng (s)","Xem"])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setHidden(True); colR.addWidget(self.table, 0)

        # Result tabs
        from PyQt5.QtWidgets import QTabWidget, QScrollArea
        self.result_tabs = QTabWidget()

        # Tab 1: Script Details
        script_widget = QWidget()
        script_layout = QVBoxLayout(script_widget)
        script_layout.setContentsMargins(4, 4, 4, 4)
        self.view_story = QTextEdit()
        self.view_story.setReadOnly(True)
        self.view_story.setPlaceholderText("K·ªãch b·∫£n chi ti·∫øt s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y")
        script_layout.addWidget(self.view_story)
        self.result_tabs.addTab(script_widget, "üìù Chi ti·∫øt k·ªãch b·∫£n")

        # Tab 2: Character Bible
        bible_widget = QWidget()
        bible_layout = QVBoxLayout(bible_widget)
        bible_layout.setContentsMargins(8, 8, 8, 8)
        self.btn_generate_bible = QPushButton("‚ú® T·∫°o Character Bible")
        self.btn_generate_bible.setObjectName("btn_primary")
        self.btn_generate_bible.setEnabled(False)
        bible_layout.addWidget(self.btn_generate_bible)
        self.view_bible = QTextEdit()
        self.view_bible.setReadOnly(False)
        bible_layout.addWidget(self.view_bible)
        self.result_tabs.addTab(bible_widget, "üìñ Character Bible")

        # Tab 3: Scene Results (CARD-BASED LAYOUT)
        scenes_widget = QWidget()
        scenes_layout = QVBoxLayout(scenes_widget)
        scenes_layout.setContentsMargins(4, 4, 4, 4)
        
        # Scroll area for cards
        self.cards_scroll = QScrollArea()
        self.cards_scroll.setWidgetResizable(True)
        self.cards_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # Container widget for cards
        cards_container = QWidget()
        self.cards_layout = QVBoxLayout(cards_container)
        self.cards_layout.setSpacing(12)
        self.cards_layout.setContentsMargins(8, 8, 8, 8)
        
        self.cards_scroll.setWidget(cards_container)
        scenes_layout.addWidget(self.cards_scroll)
        
        self.result_tabs.addTab(scenes_widget, "üé¨ K·∫øt qu·∫£ c·∫£nh")

        # Tab 4: Thumbnail
        thumbnail_widget = QWidget()
        thumbnail_layout = QVBoxLayout(thumbnail_widget)
        self.thumbnail_display = QTextEdit()
        self.thumbnail_display.setReadOnly(True)
        thumbnail_layout.addWidget(self.thumbnail_display)
        self.result_tabs.addTab(thumbnail_widget, "üì∫ Thumbnail")

        # Tab 5: Social
        social_widget = QWidget()
        social_layout = QVBoxLayout(social_widget)
        self.social_display = QTextEdit()
        self.social_display.setReadOnly(True)
        social_layout.addWidget(self.social_display)
        self.result_tabs.addTab(social_widget, "üì± Social")

        colR.addWidget(self.result_tabs, 1)

        root.addLayout(colL,1); root.addLayout(colR,2)

        # Wire up
        self.btn_auto.clicked.connect(self._on_auto_generate)
        self.btn_stop.clicked.connect(self.stop_processing)
        self.table.cellDoubleClicked.connect(self._open_prompt_view)
        self.btn_open_folder.clicked.connect(self._open_project_dir)
        self.btn_generate_bible.clicked.connect(self._on_generate_bible)

        self.worker = None
        self.thread = None
        self._cards_state = {}
        self._character_bible = None
        self._script_data = None

    def _on_language_changed(self):
        """Repopulate voices when language changes"""
        self._populate_voices()

    def _populate_voices(self):
        """Populate voice dropdown based on selected language"""
        try:
            from services.google.tts_voices import get_available_voices, format_voice_name
            
            lang_code = self.cb_out_lang.currentData()
            if not lang_code:
                lang_code = "vi"
            
            # Get first 2 chars (vi-VN ‚Üí vi)
            lang_short = lang_code.split('-')[0] if '-' in lang_code else lang_code
            
            voices = get_available_voices(lang_short)
            
            self.cb_voice.clear()
            for voice in voices:
                display_name = format_voice_name(voice)
                self.cb_voice.addItem(display_name, voice["name"])
            
            # Select first voice
            if voices:
                self.cb_voice.setCurrentIndex(0)
        
        except Exception as e:
            print(f"[WARN] Could not load voices: {e}")
            self.cb_voice.clear()
            self.cb_voice.addItem("Auto (Default)", "auto")
    def _render_card_text(self, scene:int):
        st = self._cards_state.get(scene, {})
        vi = st.get('vi','').strip()
        tgt = st.get('tgt','').strip()
        lines = [f'C·∫£nh {scene}']
        if tgt or vi:
            lines.append('‚Äî PROMPT (ƒë√≠ch/VI) ‚Äî')
            if tgt: lines.append(tgt)
            if vi: lines.append(vi)
        vids = st.get('videos', {})
        if vids:
            lines.append('‚Äî Video ‚Äî')
            for copy, info in sorted(vids.items()):
                tag = f"Video {copy}: {info.get('status','?')}"
                if info.get('completed_at'):
                    tag += f" ‚Äî ho√†n t·∫•t: {info['completed_at']}"
                if info.get('path'):
                    tag += f"\nüì• {info['path']}"
                elif info.get('url'):
                    tag += f"\nüîó {info['url']}"
                lines.append(tag)
        return '\n'.join(lines)

    def _apply_styles(self):
        # Unified theme v2 handles all styling
        pass


    def _parse_json_response(self, response):
        """Parse JSON response with error handling and auto-fix"""
        import json
        import re
        
        try:
            response_text = response.text.strip()
            
            # Remove markdown code blocks
            if response_text.startswith("```"):
                match = re.search(r'```(?:json)?\s*(.+?)```', response_text, re.DOTALL)
                if match:
                    response_text = match.group(1).strip()
                else:
                    lines = response_text.split('\n')
                    if len(lines) > 2:
                        response_text = '\n'.join(lines[1:-1])
            
            # Try parse
            result = json.loads(response_text)
            return result
            
        except json.JSONDecodeError as e:
            self._append_log(f"[ERR] JSON error at line {e.lineno}, col {e.colno}: {e.msg}")
            self._append_log(f"[DEBUG] Response: {response_text[:300]}")
            
            # Auto-fix attempts
            try:
                # Remove trailing commas
                fixed = re.sub(r',\s*}', '}', response_text)
                fixed = re.sub(r',\s*]', ']', fixed)
                
                # Fix unescaped quotes in strings
                # (This is complex, basic attempt only)
                
                result = json.loads(fixed)
                self._append_log("[INFO] ‚úì Auto-fixed JSON")
                return result
                
            except Exception as fix_err:
                self._append_log(f"[ERR] Cannot fix: {fix_err}")
                
                # Last resort: Try to extract scenes manually
                try:
                    scenes = self._extract_scenes_fallback(response_text)
                    if scenes:
                        self._append_log("[INFO] ‚úì Extracted scenes using fallback")
                        return {"scenes": scenes}
                except:
                    pass
                
                return None
    
    def _extract_scenes_fallback(self, text):
        """Fallback: Extract scenes from malformed JSON"""
        import re
        
        scenes = []
        
        # Try to find scene patterns
        # Example: "scene_description": "..."
        desc_pattern = r'"scene_description"\s*:\s*"([^"]+)"'
        dialog_pattern = r'"dialog_text"\s*:\s*"([^"]+)"'
        prompt_pattern = r'"prompt"\s*:\s*"([^"]+)"'
        
        desc_matches = re.findall(desc_pattern, text)
        dialog_matches = re.findall(dialog_pattern, text)
        prompt_matches = re.findall(prompt_pattern, text)
        
        for i, desc in enumerate(desc_matches):
            scene = {
                "index": i + 1,
                "scene_description": desc,
                "dialog_text": dialog_matches[i] if i < len(dialog_matches) else "",
                "prompt": prompt_matches[i] if i < len(prompt_matches) else desc,
            }
            scenes.append(scene)
        
        return scenes if scenes else None


    def _display_scene_cards(self, scenes):
        """Display scenes as cards (like Video B√°n H√†ng)"""
        # Clear existing cards
        while self.cards_layout.count():
            item = self.cards_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        if not scenes:
            no_data = QLabel("Ch∆∞a c√≥ c·∫£nh. T·∫°o k·ªãch b·∫£n tr∆∞·ªõc.")
            no_data.setStyleSheet("color: #999; padding: 40px; font-size: 14px; text-align: center;")
            no_data.setAlignment(Qt.AlignCenter)
            self.cards_layout.addWidget(no_data)
            return
        
        # Create card for each scene
        for idx, scene in enumerate(scenes):
            card = self._create_scene_card(scene, idx)
            self.cards_layout.addWidget(card)
        
        # Add stretch at bottom
        self.cards_layout.addStretch()
        
        # Auto-open this tab
        self.result_tabs.setCurrentIndex(2)  # Tab 3: "K·∫øt qu·∫£ c·∫£nh"
    
    def _create_scene_card(self, scene, idx):
        """Create single scene card widget"""
        from PyQt5.QtWidgets import QFrame, QHBoxLayout, QVBoxLayout
        
        card = QFrame()
        card.setFrameShape(QFrame.StyledPanel)
        card.setStyleSheet("""
            QFrame {
                background-color: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 12px;
            }
            QFrame:hover {
                border: 1px solid #1976D2;
            }
        """)
        
        h_layout = QHBoxLayout(card)
        h_layout.setSpacing(12)
        
        # Left: Preview image placeholder
        preview = QFrame()
        preview.setFixedSize(150, 100)
        preview.setStyleSheet("""
            QFrame {
                background-color: #f5f5f5;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        preview_layout = QVBoxLayout(preview)
        preview_label = QLabel("Ch∆∞a t·∫°o")
        preview_label.setAlignment(Qt.AlignCenter)
        preview_label.setStyleSheet("color: #999; font-size: 12px;")
        preview_layout.addWidget(preview_label)
        h_layout.addWidget(preview)
        
        # Right: Content
        content_layout = QVBoxLayout()
        content_layout.setSpacing(6)
        
        # Title
        title = QLabel(f"<b style='font-size: 16px; color: #1976D2;'>C·∫£nh {idx + 1}</b>")
        content_layout.addWidget(title)
        
        # Description (truncate at 150 chars)
        desc = scene.get("scene_description", "") or scene.get("prompt_vi", "")
        if len(desc) > 150:
            desc = desc[:150] + "..."
        desc_label = QLabel(desc)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("font-size: 13px; color: #333; margin-bottom: 4px;")
        content_layout.addWidget(desc_label)
        
        # Dialog text
        dialog = scene.get("dialog_text", "")
        if dialog:
            if len(dialog) > 100:
                dialog = dialog[:100] + "..."
            dialog_label = QLabel(f"üé§ L·ªùi tho·∫°i: {dialog}")
            dialog_label.setWordWrap(True)
            dialog_label.setStyleSheet("font-size: 12px; color: #666; font-style: italic;")
            content_layout.addWidget(dialog_label)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(8)
        
        btn_prompt = QPushButton("üìù Prompt")
        btn_prompt.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        btn_prompt.clicked.connect(lambda: self._show_scene_prompt(scene))
        btn_layout.addWidget(btn_prompt)
        
        btn_regen = QPushButton("üîÑ T·∫°o l·∫°i")
        btn_regen.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        btn_regen.clicked.connect(lambda: self._regenerate_scene(idx))
        btn_layout.addWidget(btn_regen)
        
        btn_video = QPushButton("üé¨ T·∫°o Video")
        btn_video.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        btn_video.clicked.connect(lambda: self._generate_video_single_scene(idx))
        btn_layout.addWidget(btn_video)
        
        btn_layout.addStretch()
        content_layout.addLayout(btn_layout)
        
        h_layout.addLayout(content_layout, stretch=1)
        
        return card
    
    def _show_scene_prompt(self, scene):
        """Show prompt in dialog"""
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Video Prompt")
        dialog.resize(700, 500)
        
        layout = QVBoxLayout(dialog)
        
        text_edit = QTextEdit()
        prompt_text = scene.get("prompt", "") or scene.get("prompt_tgt", "") or scene.get("prompt_vi", "")
        text_edit.setPlainText(prompt_text)
        text_edit.setReadOnly(True)
        layout.addWidget(text_edit)
        
        btn_close = QPushButton("ƒê√≥ng")
        btn_close.clicked.connect(dialog.close)
        layout.addWidget(btn_close)
        
        dialog.exec_()
    
    def _regenerate_scene(self, scene_idx):
        """Regenerate specific scene"""
        self._append_log(f"[TODO] T·∫°o l·∫°i c·∫£nh {scene_idx + 1}")
    
    def _generate_video_single_scene(self, scene_idx):
        """Generate video for single scene only"""
        self._append_log(f"ƒêang t·∫°o video cho c·∫£nh {scene_idx + 1}...")
        # TODO: Implement single scene video generation

    def _append_log(self, msg):
        self.console.append(msg)

    def stop_processing(self):
        """PR#4: Stop all workers"""
        if self.worker:
            self.worker.should_stop = True
            self._append_log("[INFO] ƒêang d·ª´ng x·ª≠ l√Ω...")

        self.btn_auto.setEnabled(True)
        self.btn_stop.setEnabled(False)

    def _on_auto_generate(self):
        """PR#4: Auto-generate - runs script generation then video creation"""
        idea = self.ed_idea.toPlainText().strip()
        if not idea:
            QMessageBox.warning(self, "Thi·∫øu th√¥ng tin", "Nh·∫≠p √Ω t∆∞·ªüng tr∆∞·ªõc.")
            return

        self.btn_auto.setEnabled(False)
        self.btn_stop.setEnabled(True)

        # Step 1: Generate script
        payload = dict(
            project=self.ed_project.text().strip(),
            idea=idea,
            style=self.cb_style.currentText(),
            duration=int(self.sp_duration.value()),
            provider="Gemini 2.5",
            out_lang_code=self.cb_out_lang.currentData()
        )
        self._append_log("[INFO] B∆∞·ªõc 1/3: Sinh k·ªãch b·∫£n...")
        self._run_in_thread("script", payload)

    def _on_write_script_clicked(self):
        """Legacy script generation"""
        idea = self.ed_idea.toPlainText().strip()
        if not idea: QMessageBox.warning(self,"Thi·∫øu th√¥ng tin","Nh·∫≠p √Ω t∆∞·ªüng tr∆∞·ªõc."); return
        payload = dict(
            project=self.ed_project.text().strip(),
            idea=idea, style=self.cb_style.currentText(),
            duration=int(self.sp_duration.value()),
            provider="Gemini 2.5",
            out_lang_code=self.cb_out_lang.currentData()
        )
        self._append_log("[INFO] Y√™u c·∫ßu sinh k·ªãch b·∫£n...")
        self._run_in_thread("script", payload)

    def _on_create_video_clicked(self):
        if self.table.rowCount()<=0: QMessageBox.information(self,"Ch∆∞a c√≥ k·ªãch b·∫£n","H√£y t·∫°o k·ªãch b·∫£n tr∆∞·ªõc."); return
        lang_code=self.cb_out_lang.currentData()
        ratio_key=self.cb_ratio.currentText()
        ratio = _ASPECT_MAP.get(ratio_key,"VIDEO_ASPECT_RATIO_LANDSCAPE")
        style=self.cb_style.currentText()
        scenes=[]

        # Part D: Get character bible for injection
        character_bible_basic = self._script_data.get("character_bible", []) if self._script_data else []

        for r in range(self.table.rowCount()):
            vi = self.table.item(r,1).text() if self.table.item(r,1) else ""
            tgt= self.table.item(r,2).text() if self.table.item(r,2) else vi

            # Part D: Pass enhanced bible to build_prompt_json
            j=build_prompt_json(
                r+1, vi, tgt, lang_code, ratio_key, style,
                character_bible=character_bible_basic,
                enhanced_bible=self._character_bible
            )
            scenes.append({"prompt": json.dumps(j, ensure_ascii=False, indent=2), "aspect": ratio})

        payload=dict(
            scenes=scenes, copies=self._t2v_get_copies(), model_key=self.cb_model.currentText(),
            title=self._title, dir_videos=self._ctx.get("dir_videos",""),
            upscale_4k=self.cb_upscale.isChecked(),  # PR#4: Use checkbox instead of button
            auto_download=self.cb_auto_download.isChecked(),  # Part D: Auto-download flag
            quality="720p"  # Video quality (1080p/720p)
        )
        if not payload["dir_videos"]:
            st=cfg.load(); root=st.get("download_dir") or ""
            if not root:
                QMessageBox.warning(self,"Thi·∫øu c·∫•u h√¨nh","V√†o tab C√†i ƒë·∫∑t ƒë·ªÉ ch·ªçn 'Th∆∞ m·ª•c t·∫£i v·ªÅ' tr∆∞·ªõc."); return
            import os; prj=os.path.join(root, self._title or "Project"); os.makedirs(prj, exist_ok=True)
            payload["dir_videos"]=os.path.join(prj,"03_Videos"); os.makedirs(payload["dir_videos"], exist_ok=True)
        self._append_log("[INFO] B·∫Øt ƒë·∫ßu t·∫°o video...")
        self._run_in_thread("video", payload)

    def _run_in_thread(self, task, payload):
        # PR#4: Store worker and thread references for stop functionality
        self.thread = QThread(self)
        self.worker = _Worker(task, payload)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.log.connect(self._append_log)
        if task=="script":
            self.worker.story_done.connect(self._on_story_ready)
        else:
            self.worker.job_card.connect(self._on_job_card)
            self.worker.job_finished.connect(lambda: self._on_worker_finished())
        self.thread.start()

    def _on_worker_finished(self):
        """PR#4: Re-enable buttons when worker completes"""
        self._append_log("[INFO] Worker ho√†n t·∫•t.")
        self.btn_auto.setEnabled(True)
        self.btn_stop.setEnabled(False)

    def _on_story_ready(self, data, ctx):
        self._ctx = ctx
        # title/project
        self._title = self.ed_project.text().strip() or data.get("title_vi") or data.get("title_tgt") or ctx.get("title")
        # show Bible + Outline + Screenplay
        parts=[]
        cb = data.get("character_bible") or []
        if cb:
            parts.append("=== H·ªí S∆† NH√ÇN V·∫¨T ===")
            for c in cb:
                parts.append(f"- {c.get('name','?')} [{c.get('role','?')}]: key_trait={c.get('key_trait','')}; motivation={c.get('motivation','')}; default={c.get('default_behavior','')}; visual={c.get('visual_identity','')}; archetype={c.get('archetype','')}; fatal_flaw={c.get('fatal_flaw','')}")
        ol_vi = data.get("outline_vi","" ).strip()
        if ol_vi: parts.append("\n=== D√ÄN √ù ===\n"+ol_vi)
        sp_vi = data.get("screenplay_vi","" ).strip()
        sp_tgt = data.get("screenplay_tgt","" ).strip()
        if sp_vi or sp_tgt: parts.append(f"\n=== K·ªäCH B·∫¢N (VI) ===\n{sp_vi}\n\n=== SCREENPLAY ===\n{sp_tgt}")
        self.view_story.setPlainText("\n\n".join(parts) if parts else "(Kh√¥ng c√≥ d·ªØ li·ªáu)")
        
        # Display scene cards
        scenes = data.get('scenes', [])
        self._display_scene_cards(scenes)

        self.cards.clear()
        self._cards_state = {}
        for i, sc in enumerate(data.get('scenes', []), 1):
            vi = sc.get('prompt_vi','')
            tgt = sc.get('prompt_tgt','')
            self._cards_state[i] = {'vi': vi, 'tgt': tgt, 'thumb':'', 'videos':{}}
            it = QListWidgetItem(self._render_card_text(i))
            it.setData(Qt.UserRole, ('scene', i))
            self.cards.addItem(it)

        # fill table & save prompts
        self.table.setRowCount(0)
        prdir = ctx.get("dir_prompts","" )
        for i, sc in enumerate(data.get("scenes", []), 1):
            r=self.table.rowCount(); self.table.insertRow(r)
            self.table.setItem(r,0,QTableWidgetItem(str(i)))
            self.table.setItem(r,1,QTableWidgetItem(sc.get("prompt_vi","" )))
            self.table.setItem(r,2,QTableWidgetItem(sc.get("prompt_tgt","" )))
            self.table.setItem(r,3,QTableWidgetItem(self.cb_ratio.currentText()))
            self.table.setItem(r,4,QTableWidgetItem(str(sc.get("duration",8))))
            btn = QPushButton("Xem"); btn.clicked.connect(lambda _=None, row=r: self._open_prompt_view(row))
            self.table.setCellWidget(r,5,btn)
            # save prompt json per scene
            try:
                lang_code=self.cb_out_lang.currentData()
                # Part D: Will be enhanced with bible later when user generates it
                character_bible_basic = data.get("character_bible", [])
                j=build_prompt_json(
                    i, sc.get("prompt_vi","" ), sc.get("prompt_tgt","" ), lang_code,
                    self.cb_ratio.currentText(), self.cb_style.currentText(),
                    character_bible=character_bible_basic
                )
                if prdir:
                    with open(os.path.join(prdir, f"scene_{i:02d}.json"), "w", encoding="utf-8") as f:
                        json.dump(j, f, ensure_ascii=False, indent=2)
            except Exception: pass
        self._append_log("[INFO] K·ªãch b·∫£n ƒë√£ hi·ªÉn th·ªã & l∆∞u file.")

        # Part D: Store script data and enable bible generation button
        self._script_data = data
        self.btn_generate_bible.setEnabled(True)

        # Part D: Auto-generate character bible if exists in data
        cb = data.get("character_bible") or []
        if cb:
            self._generate_character_bible_from_data(data)

        # PR#4: If stop button is enabled (auto mode), automatically start video generation
        if not self.btn_stop.isEnabled():
            # Normal mode - re-enable auto button
            self.btn_auto.setEnabled(True)
        else:
            # Auto mode - proceed to step 2 (video generation)
            self._append_log("[INFO] B∆∞·ªõc 2/3: B·∫Øt ƒë·∫ßu t·∫°o video...")
            self._on_create_video_clicked()

    def _open_project_dir(self):
        d = self._ctx.get("prj_dir")
        if d and os.path.isdir(d):
            QDesktopServices.openUrl(QUrl.fromLocalFile(d))
        else:
            QMessageBox.information(self,"Ch∆∞a c√≥ th∆∞ m·ª•c","H√£y vi·∫øt k·ªãch b·∫£n tr∆∞·ªõc ƒë·ªÉ t·∫°o c·∫•u tr√∫c d·ª± √°n.")

    def _open_prompt_view(self, row):
        if row<0 or row>=self.table.rowCount(): return
        vi = self.table.item(row,1).text() if self.table.item(row,1) else ""
        tgt= self.table.item(row,2).text() if self.table.item(row,2) else ""
        lang_code=self.cb_out_lang.currentData()
        j=build_prompt_json(row+1, vi, tgt, lang_code, self.cb_ratio.currentText(), self.cb_style.currentText())
        from ui.prompt_viewer import PromptViewer
        dlg = PromptViewer(json.dumps(j, ensure_ascii=False, indent=2), None, self); dlg.exec_()


    def _on_job_card(self, data:dict):
        scene = int(data.get('scene', 0) or 0)
        copy  = int(data.get('copy', 0) or 0)
        if scene <= 0 or copy <= 0: return
        st = self._cards_state.setdefault(scene, {'vi':'','tgt':'','thumb':'','videos':{}})
        v  = st['videos'].setdefault(copy, {})
        for k in ('status','url','path','thumb','completed_at'):
            if data.get(k): v[k] = data.get(k)
        if data.get('thumb') and os.path.isfile(data['thumb']):
            st['thumb'] = data['thumb']
        for i in range(self.cards.count()):
            it = self.cards.item(i)
            role = it.data(Qt.UserRole)
            if isinstance(role, tuple) and role == ('scene', scene):
                it.setText(self._render_card_text(scene))
                if st.get('thumb') and os.path.isfile(st['thumb']):
                    from PyQt5.QtGui import QIcon, QPixmap
                    pix=QPixmap(st['thumb']).scaled(self.cards.iconSize(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    it.setIcon(QIcon(pix))
                col = self._t2v_status_color(v.get('status'))
                if col: it.setBackground(col)
                break

    def _t2v_status_color(self, status):
        s = (status or "").upper()
        if s in ("QUEUED","PROCESSING","RENDERING","DOWNLOADING"): return QColor("#36D1BE")
        if s in ("COMPLETED","DOWNLOADED","UPSCALED_4K"): return QColor("#3FD175")
        if s in ("ERROR","FAILED"): return QColor("#ED6D6A")
        return None

    def _t2v_tick(self):
        try:
            self._spin_idx = (self._spin_idx + 1) % len(self._spin_frames)
            if hasattr(self, "table") and self.table is not None:
                rows = self.table.rowCount()
                for r in range(rows):
                    it = self.table.item(r, 3)  # status col
                    if not it:
                        continue
                    status = (it.text() or "").upper()
                    col = self._t2v_status_color(status)
                    if col: it.setBackground(col)
                    if status in ("QUEUED","PROCESSING","RENDERING","DOWNLOADING"):
                        base = status.title()
                        it.setText(base + " " + self._spin_frames[self._spin_idx])
            if hasattr(self, "cards") and self.cards is not None:
                for i in range(self.cards.count()):
                    it = self.cards.item(i)
                    txt = it.text()
                    if any(k in txt for k in ["PROCESSING","RENDERING","DOWNLOADING","QUEUED"]):
                        tail = " " + self._spin_frames[self._spin_idx]
                        if not txt.endswith(tail): it.setText(txt + tail)
        except Exception:
            pass

    def _t2v_get_copies(self):
        # Try common spinbox names; fallback 2
        cand = ["sp_copies","sb_copies","spin_copies","sp_num_videos","spVideos","sp_copies_per_scene"]
        for name in cand:
            try:
                w = getattr(self, name)
                val = int(w.value())
                if val >= 1:
                    return val
            except Exception:
                pass
        return 2

    def _open_card_prompt(self, it):
        try:
            role = it.data(Qt.UserRole)
            scene = None
            if isinstance(role, tuple) and role[0]=='scene':
                scene = int(role[1])
            if not scene:
                return
            st = self._cards_state.get(scene, {})
            txt = st.get('prompt_json','')
            if not txt:
                pr = getattr(self, '_project_root', '')
                if pr:
                    p = os.path.join(pr, '02_Prompts', f'scene_{scene:02d}.json')
                    if os.path.isfile(p):
                        try:
                            txt = open(p,'r',encoding='utf-8').read()
                        except Exception:
                            pass
            if not txt:
                return
            from ui.prompt_viewer import PromptViewer
            dlg = PromptViewer(txt, None, self)
            dlg.exec_()
        except Exception:
            pass

    def _on_generate_bible(self):
        """Part D: Generate detailed character bible"""
        if not self._script_data:
            QMessageBox.warning(self, "Ch∆∞a c√≥ k·ªãch b·∫£n", "H√£y t·∫°o k·ªãch b·∫£n tr∆∞·ªõc khi t·∫°o Character Bible.")
            return

        self._append_log("[INFO] ƒêang t·∫°o Character Bible chi ti·∫øt...")
        self._generate_character_bible_from_data(self._script_data)
        self._append_log("[INFO] Character Bible ƒë√£ t·∫°o xong.")

    def _display_scenes(self, outline):
    """Display scenes in card-based layout"""
    # Clear previous
    while self.scenes_layout.count():
        item = self.scenes_layout.takeAt(0)
        if item.widget():
            item.widget().deleteLater()
         scenes = outline.get("scenes", [])
    if not scenes:
        label = QLabel("Ch∆∞a c√≥ c·∫£nh. T·∫°o k·ªãch b·∫£n tr∆∞·ªõc.")
        label.setStyleSheet("color: #999; padding: 20px;")
        label.setAlignment(Qt.AlignCenter)
        self.scenes_layout.addWidget(label)
        return
         # Show first scene by default
    if not hasattr(self, 'current_scene_index'):
        self.current_scene_index = 0
         # Create cards for all scenes
    for idx, scene in enumerate(scenes):
        card = self._create_scene_card(scene, idx)
        self.scenes_layout.addWidget(card)
         self.scenes_layout.addStretch()
     def _create_scene_card(self, scene, idx):
        """Create scene card widget"""
        card = QFrame()
        card.setFrameShape(QFrame.StyledPanel)
        card.setStyleSheet("""
            QFrame {
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
            }
            QFrame:hover {
                border: 1px solid #1976D2;
            }
        """)
        
        h_layout = QHBoxLayout(card)
        
        # Preview image
        preview = QFrame()
        preview.setFixedSize(200, 150)
        preview.setStyleSheet("background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;")
        preview_layout = QVBoxLayout(preview)
        preview_label = QLabel("Ch∆∞a t·∫°o")
        preview_label.setAlignment(Qt.AlignCenter)
        preview_label.setStyleSheet("color: #999;")
        preview_layout.addWidget(preview_label)
        h_layout.addWidget(preview)
        
        # Content
        content_layout = QVBoxLayout()
        
        title = QLabel(f"<b>C·∫£nh {idx + 1}</b>")
        title.setStyleSheet("font-size: 16px; color: #1976D2;")
        content_layout.addWidget(title)
        
        desc = scene.get("scene_description", "")[:150]
        desc_label = QLabel(desc + "..." if len(scene.get("scene_description", "")) > 150 else desc)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("font-size: 13px; color: #333;")
        content_layout.addWidget(desc_label)
        
        dialog = scene.get("dialog_text", "")
        if dialog:
            dialog_label = QLabel(f"üìù {dialog[:100]}...")
            dialog_label.setWordWrap(True)
            dialog_label.setStyleSheet("font-size: 12px; color: #666; font-style: italic;")
            content_layout.addWidget(dialog_label)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        btn_prompt = QPushButton("üìù Prompt")
        btn_prompt.setStyleSheet("background: #FF9800; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_prompt.clicked.connect(lambda: self._show_prompt(scene))
        btn_layout.addWidget(btn_prompt)
        
        btn_regen = QPushButton("üì∏ T·∫°o l·∫°i")
        btn_regen.setStyleSheet("background: #2196F3; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_layout.addWidget(btn_regen)
        
        btn_video = QPushButton("üé¨ T·∫°o Video")
        btn_video.setStyleSheet("background: #4CAF50; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_video.clicked.connect(lambda: self._generate_video_for_scene(idx))
        btn_layout.addWidget(btn_video)
        
        btn_layout.addStretch()
        content_layout.addLayout(btn_layout)
        
        h_layout.addLayout(content_layout, stretch=1)
        
        return card
    
    def _show_prompt(self, scene):
        """Show prompt dialog"""
        from PyQt5.QtWidgets import QDialog, QTextEdit, QPushButton, QVBoxLayout
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Video Prompt")
        dialog.resize(600, 400)
        
        layout = QVBoxLayout(dialog)
        text = QTextEdit()
        text.setPlainText(scene.get("prompt", ""))
        text.setReadOnly(True)
        layout.addWidget(text)
        
        btn = QPushButton("ƒê√≥ng")
        btn.clicked.connect(dialog.close)
        layout.addWidget(btn)
        
        dialog.exec_()
    
    def _generate_video_for_scene(self, idx):
        """Generate video for specific scene"""
        self._append_log(f"B·∫Øt ƒë·∫ßu t·∫°o video c·∫£nh {idx + 1}...")
        # TODO: Call video generation
    
    def _poll_video_status(self, video_id, scene_idx, max_wait=300):
        """Poll Google Labs for video completion and download"""
        import time
        from services.google.veo2_service import get_video_status, download_video
        
        self._append_log(f"[C·∫£nh {scene_idx + 1}] ƒêang ch·ªù video...")
        
        elapsed = 0
        while elapsed < max_wait:
            try:
                status = get_video_status(video_id)
                state = status.get("state", "UNKNOWN")
                
                if state == "COMPLETED":
                    self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚úì Ho√†n th√†nh!")
                    
                    video_url = status.get("downloadUrl") or status.get("video", {}).get("uri")
                    if video_url:
                        video_bytes = download_video(video_url)
                        if video_bytes:
                            # Save video
                            import os
                            video_dir = "cache/text2video/videos"
                            os.makedirs(video_dir, exist_ok=True)
                            
                            video_path = os.path.join(video_dir, f"scene_{scene_idx + 1}_{video_id[:8]}.mp4")
                            with open(video_path, 'wb') as f:
                                f.write(video_bytes)
                            
                            self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚úì ƒê√£ l∆∞u: {video_path}")
                            return video_path
                    
                    return None
                
                elif state == "FAILED":
                    self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚ùå Th·∫•t b·∫°i")
                    return None
                
                elif state in ["PENDING", "PROCESSING"]:
                    if elapsed % 25 == 0:
                        self._append_log(f"[C·∫£nh {scene_idx + 1}] ƒêang x·ª≠ l√Ω... {elapsed}s")
                    time.sleep(5)
                    elapsed += 5
                
            except Exception as e:
                self._append_log(f"[C·∫£nh {scene_idx + 1}] L·ªói: {e}")
                time.sleep(5)
                elapsed += 5
        
        self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚ùå Timeout")
        return None
    def _create_scene_card(self, scene, idx):
        """Create scene card widget"""
        card = QFrame()
        card.setFrameShape(QFrame.StyledPanel)
        card.setStyleSheet("""
            QFrame {
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
            }
            QFrame:hover {
                border: 1px solid #1976D2;
            }
        """)
        
        h_layout = QHBoxLayout(card)
        
        # Preview image
        preview = QFrame()
        preview.setFixedSize(200, 150)
        preview.setStyleSheet("background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;")
        preview_layout = QVBoxLayout(preview)
        preview_label = QLabel("Ch∆∞a t·∫°o")
        preview_label.setAlignment(Qt.AlignCenter)
        preview_label.setStyleSheet("color: #999;")
        preview_layout.addWidget(preview_label)
        h_layout.addWidget(preview)
        
        # Content
        content_layout = QVBoxLayout()
        
        title = QLabel(f"<b>C·∫£nh {idx + 1}</b>")
        title.setStyleSheet("font-size: 16px; color: #1976D2;")
        content_layout.addWidget(title)
        
        desc = scene.get("scene_description", "")[:150]
        desc_label = QLabel(desc + "..." if len(scene.get("scene_description", "")) > 150 else desc)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("font-size: 13px; color: #333;")
        content_layout.addWidget(desc_label)
        
        dialog = scene.get("dialog_text", "")
        if dialog:
            dialog_label = QLabel(f"üìù {dialog[:100]}...")
            dialog_label.setWordWrap(True)
            dialog_label.setStyleSheet("font-size: 12px; color: #666; font-style: italic;")
            content_layout.addWidget(dialog_label)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        btn_prompt = QPushButton("üìù Prompt")
        btn_prompt.setStyleSheet("background: #FF9800; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_prompt.clicked.connect(lambda: self._show_prompt(scene))
        btn_layout.addWidget(btn_prompt)
        
        btn_regen = QPushButton("üì∏ T·∫°o l·∫°i")
        btn_regen.setStyleSheet("background: #2196F3; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_layout.addWidget(btn_regen)
        
        btn_video = QPushButton("üé¨ T·∫°o Video")
        btn_video.setStyleSheet("background: #4CAF50; color: white; border: none; border-radius: 4px; padding: 6px 12px;")
        btn_video.clicked.connect(lambda: self._generate_video_for_scene(idx))
        btn_layout.addWidget(btn_video)
        
        btn_layout.addStretch()
        content_layout.addLayout(btn_layout)
        
        h_layout.addLayout(content_layout, stretch=1)
        
        return card
    
    def _show_prompt(self, scene):
        """Show prompt dialog"""
        from PyQt5.QtWidgets import QDialog, QTextEdit, QPushButton, QVBoxLayout
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Video Prompt")
        dialog.resize(600, 400)
        
        layout = QVBoxLayout(dialog)
        text = QTextEdit()
        text.setPlainText(scene.get("prompt", ""))
        text.setReadOnly(True)
        layout.addWidget(text)
        
        btn = QPushButton("ƒê√≥ng")
        btn.clicked.connect(dialog.close)
        layout.addWidget(btn)
        
        dialog.exec_()
    
    def _generate_video_for_scene(self, idx):
        """Generate video for specific scene"""
        self._append_log(f"B·∫Øt ƒë·∫ßu t·∫°o video c·∫£nh {idx + 1}...")
        # TODO: Call video generation
    
    def _poll_video_status(self, video_id, scene_idx, max_wait=300):
        """Poll Google Labs for video completion and download"""
        import time
        from services.google.veo2_service import get_video_status, download_video
        
        self._append_log(f"[C·∫£nh {scene_idx + 1}] ƒêang ch·ªù video...")
        
        elapsed = 0
        while elapsed < max_wait:
            try:
                status = get_video_status(video_id)
                state = status.get("state", "UNKNOWN")
                
                if state == "COMPLETED":
                    self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚úì Ho√†n th√†nh!")
                    
                    video_url = status.get("downloadUrl") or status.get("video", {}).get("uri")
                    if video_url:
                        video_bytes = download_video(video_url)
                        if video_bytes:
                            # Save video
                            import os
                            video_dir = "cache/text2video/videos"
                            os.makedirs(video_dir, exist_ok=True)
                            
                            video_path = os.path.join(video_dir, f"scene_{scene_idx + 1}_{video_id[:8]}.mp4")
                            with open(video_path, 'wb') as f:
                                f.write(video_bytes)
                            
                            self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚úì ƒê√£ l∆∞u: {video_path}")
                            return video_path
                    
                    return None
                
                elif state == "FAILED":
                    self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚ùå Th·∫•t b·∫°i")
                    return None
                
                elif state in ["PENDING", "PROCESSING"]:
                    if elapsed % 25 == 0:
                        self._append_log(f"[C·∫£nh {scene_idx + 1}] ƒêang x·ª≠ l√Ω... {elapsed}s")
                    time.sleep(5)
                    elapsed += 5
                
            except Exception as e:
                self._append_log(f"[C·∫£nh {scene_idx + 1}] L·ªói: {e}")
                time.sleep(5)
                elapsed += 5
        
        self._append_log(f"[C·∫£nh {scene_idx + 1}] ‚ùå Timeout")
        return None
